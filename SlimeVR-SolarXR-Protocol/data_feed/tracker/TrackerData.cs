// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace solarxr_protocol.data_feed.tracker
{

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// Describes all possible information about a tracker. A tracker is anything that
/// provides kinematic data about a particular body part.
///
/// Trackers may be synthetic/computed or instead part of an actual hardware device.
/// There can be multiple trackers per hardware device.
public struct TrackerData : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_22_10_26(); }
  public static TrackerData GetRootAsTrackerData(ByteBuffer _bb) { return GetRootAsTrackerData(_bb, new TrackerData()); }
  public static TrackerData GetRootAsTrackerData(ByteBuffer _bb, TrackerData obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TrackerData __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public solarxr_protocol.datatypes.TrackerId? TrackerId { get { int o = __p.__offset(4); return o != 0 ? (solarxr_protocol.datatypes.TrackerId?)(new solarxr_protocol.datatypes.TrackerId()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public solarxr_protocol.data_feed.tracker.TrackerInfo? Info { get { int o = __p.__offset(6); return o != 0 ? (solarxr_protocol.data_feed.tracker.TrackerInfo?)(new solarxr_protocol.data_feed.tracker.TrackerInfo()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public solarxr_protocol.datatypes.TrackerStatus Status { get { int o = __p.__offset(8); return o != 0 ? (solarxr_protocol.datatypes.TrackerStatus)__p.bb.Get(o + __p.bb_pos) : solarxr_protocol.datatypes.TrackerStatus.NONE; } }
  /// Sensor rotation after fusion
  public solarxr_protocol.datatypes.math.Quat? Rotation { get { int o = __p.__offset(10); return o != 0 ? (solarxr_protocol.datatypes.math.Quat?)(new solarxr_protocol.datatypes.math.Quat()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// Position, in meters
  public solarxr_protocol.datatypes.math.Vec3f? Position { get { int o = __p.__offset(12); return o != 0 ? (solarxr_protocol.datatypes.math.Vec3f?)(new solarxr_protocol.datatypes.math.Vec3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// Raw angular velocity, in euler angles, rad/s
  public solarxr_protocol.datatypes.math.Vec3f? RawAngularVelocity { get { int o = __p.__offset(14); return o != 0 ? (solarxr_protocol.datatypes.math.Vec3f?)(new solarxr_protocol.datatypes.math.Vec3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// Raw acceleration, in m/s^2
  public solarxr_protocol.datatypes.math.Vec3f? RawAcceleration { get { int o = __p.__offset(16); return o != 0 ? (solarxr_protocol.datatypes.math.Vec3f?)(new solarxr_protocol.datatypes.math.Vec3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// Temperature, in degrees celsius
  public solarxr_protocol.datatypes.Temperature? Temp { get { int o = __p.__offset(18); return o != 0 ? (solarxr_protocol.datatypes.Temperature?)(new solarxr_protocol.datatypes.Temperature()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// Acceleration without gravity, in m/s^2
  public solarxr_protocol.datatypes.math.Vec3f? LinearAcceleration { get { int o = __p.__offset(20); return o != 0 ? (solarxr_protocol.datatypes.math.Vec3f?)(new solarxr_protocol.datatypes.math.Vec3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// Reference-adjusted rotation for IMU-only trackers (VR HMD yaw is used as a reset reference).
  /// In other words, a rotation that is aligned to a reliable source of rotation ((0, VR HMD YAW, 0)),
  /// triggered after user input (using reset buttons).
  /// This is a SlimeVR-specific field and computed exclusively by SlimeVR server.
  /// Includes: mounting orientation, full, quick and mounting reset adjustments.
  /// This rotation can be used to reconstruct a skeleton pose using forward kinematics.
  public solarxr_protocol.datatypes.math.Quat? RotationReferenceAdjusted { get { int o = __p.__offset(22); return o != 0 ? (solarxr_protocol.datatypes.math.Quat?)(new solarxr_protocol.datatypes.math.Quat()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// Zero-reference-adjusted rotation for IMU-only trackers (identity quaternion is used as a reset reference).
  /// In other words, a rotation that is aligned to a zero vector ((0, 0, 0)) by
  /// inverting the current rotation, triggered after user input (using reset buttons).
  /// This is a SlimeVR-specific field and computed exclusively by SlimeVR server.
  /// Includes: only full and quick reset adjustments.
  /// This rotation can be used in visualizations for IMU debugging.
  public solarxr_protocol.datatypes.math.Quat? RotationIdentityAdjusted { get { int o = __p.__offset(24); return o != 0 ? (solarxr_protocol.datatypes.math.Quat?)(new solarxr_protocol.datatypes.math.Quat()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// Data ticks per second, processed by SlimeVR server
  public ushort? Tps { get { int o = __p.__offset(26); return o != 0 ? __p.bb.GetUshort(o + __p.bb_pos) : (ushort?)null; } }

  public static void StartTrackerData(FlatBufferBuilder builder) { builder.StartTable(12); }
  public static void AddTrackerId(FlatBufferBuilder builder, Offset<solarxr_protocol.datatypes.TrackerId> trackerIdOffset) { builder.AddOffset(0, trackerIdOffset.Value, 0); }
  public static void AddInfo(FlatBufferBuilder builder, Offset<solarxr_protocol.data_feed.tracker.TrackerInfo> infoOffset) { builder.AddOffset(1, infoOffset.Value, 0); }
  public static void AddStatus(FlatBufferBuilder builder, solarxr_protocol.datatypes.TrackerStatus status) { builder.AddByte(2, (byte)status, 0); }
  public static void AddRotation(FlatBufferBuilder builder, Offset<solarxr_protocol.datatypes.math.Quat> rotationOffset) { builder.AddStruct(3, rotationOffset.Value, 0); }
  public static void AddPosition(FlatBufferBuilder builder, Offset<solarxr_protocol.datatypes.math.Vec3f> positionOffset) { builder.AddStruct(4, positionOffset.Value, 0); }
  public static void AddRawAngularVelocity(FlatBufferBuilder builder, Offset<solarxr_protocol.datatypes.math.Vec3f> rawAngularVelocityOffset) { builder.AddStruct(5, rawAngularVelocityOffset.Value, 0); }
  public static void AddRawAcceleration(FlatBufferBuilder builder, Offset<solarxr_protocol.datatypes.math.Vec3f> rawAccelerationOffset) { builder.AddStruct(6, rawAccelerationOffset.Value, 0); }
  public static void AddTemp(FlatBufferBuilder builder, Offset<solarxr_protocol.datatypes.Temperature> tempOffset) { builder.AddStruct(7, tempOffset.Value, 0); }
  public static void AddLinearAcceleration(FlatBufferBuilder builder, Offset<solarxr_protocol.datatypes.math.Vec3f> linearAccelerationOffset) { builder.AddStruct(8, linearAccelerationOffset.Value, 0); }
  public static void AddRotationReferenceAdjusted(FlatBufferBuilder builder, Offset<solarxr_protocol.datatypes.math.Quat> rotationReferenceAdjustedOffset) { builder.AddStruct(9, rotationReferenceAdjustedOffset.Value, 0); }
  public static void AddRotationIdentityAdjusted(FlatBufferBuilder builder, Offset<solarxr_protocol.datatypes.math.Quat> rotationIdentityAdjustedOffset) { builder.AddStruct(10, rotationIdentityAdjustedOffset.Value, 0); }
  public static void AddTps(FlatBufferBuilder builder, ushort? tps) { builder.AddUshort(11, tps); }
  public static Offset<solarxr_protocol.data_feed.tracker.TrackerData> EndTrackerData(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<solarxr_protocol.data_feed.tracker.TrackerData>(o);
  }
}


}
